{"ast":null,"code":"/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const joined = args.map(x => source(x)).join(\"\");\n  return joined;\n}\n\n/**\n * @param { Array<string | RegExp | Object> } args\n * @returns {object}\n */\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/** @typedef { {capture?: boolean} } RegexEitherOptions */\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args\n * @returns {string}\n */\nfunction either() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  /** @type { object & {capture?: boolean} }  */\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' + (opts.capture ? \"\" : \"?:\") + args.map(x => source(x)).join(\"|\") + \")\";\n  return joined;\n}\nconst keywordWrapper = keyword => concat(/\\b/, keyword, /\\w$/.test(keyword) ? /\\b/ : /\\B/);\n\n// Keywords that require a leading dot.\nconst dotKeywords = ['Protocol',\n// contextual\n'Type' // contextual\n].map(keywordWrapper);\n\n// Keywords that may have a leading dot.\nconst optionalDotKeywords = ['init', 'self'].map(keywordWrapper);\n\n// should register as keyword, not type\nconst keywordTypes = ['Any', 'Self'];\n\n// Regular keywords and literals.\nconst keywords = [\n// strings below will be fed into the regular `keywords` engine while regex\n// will result in additional modes being created to scan for those keywords to\n// avoid conflicts with other rules\n'actor', 'any',\n// contextual\n'associatedtype', 'async', 'await', /as\\?/,\n// operator\n/as!/,\n// operator\n'as',\n// operator\n'borrowing',\n// contextual\n'break', 'case', 'catch', 'class', 'consume',\n// contextual\n'consuming',\n// contextual\n'continue', 'convenience',\n// contextual\n'copy',\n// contextual\n'default', 'defer', 'deinit', 'didSet',\n// contextual\n'distributed', 'do', 'dynamic',\n// contextual\n'each', 'else', 'enum', 'extension', 'fallthrough', /fileprivate\\(set\\)/, 'fileprivate', 'final',\n// contextual\n'for', 'func', 'get',\n// contextual\n'guard', 'if', 'import', 'indirect',\n// contextual\n'infix',\n// contextual\n/init\\?/, /init!/, 'inout', /internal\\(set\\)/, 'internal', 'in', 'is',\n// operator\n'isolated',\n// contextual\n'nonisolated',\n// contextual\n'lazy',\n// contextual\n'let', 'macro', 'mutating',\n// contextual\n'nonmutating',\n// contextual\n/open\\(set\\)/,\n// contextual\n'open',\n// contextual\n'operator', 'optional',\n// contextual\n'override',\n// contextual\n'package', 'postfix',\n// contextual\n'precedencegroup', 'prefix',\n// contextual\n/private\\(set\\)/, 'private', 'protocol', /public\\(set\\)/, 'public', 'repeat', 'required',\n// contextual\n'rethrows', 'return', 'set',\n// contextual\n'some',\n// contextual\n'static', 'struct', 'subscript', 'super', 'switch', 'throws', 'throw', /try\\?/,\n// operator\n/try!/,\n// operator\n'try',\n// operator\n'typealias', /unowned\\(safe\\)/,\n// contextual\n/unowned\\(unsafe\\)/,\n// contextual\n'unowned',\n// contextual\n'var', 'weak',\n// contextual\n'where', 'while', 'willSet' // contextual\n];\n\n// NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n\n// Literals.\nconst literals = ['false', 'nil', 'true'];\n\n// Keywords used in precedence groups.\nconst precedencegroupKeywords = ['assignment', 'associativity', 'higherThan', 'left', 'lowerThan', 'none', 'right'];\n\n// Keywords that start with a number sign (#).\n// #(un)available is handled separately.\nconst numberSignKeywords = ['#colorLiteral', '#column', '#dsohandle', '#else', '#elseif', '#endif', '#error', '#file', '#fileID', '#fileLiteral', '#filePath', '#function', '#if', '#imageLiteral', '#keyPath', '#line', '#selector', '#sourceLocation', '#warning'];\n\n// Global functions in the Standard Library.\nconst builtIns = ['abs', 'all', 'any', 'assert', 'assertionFailure', 'debugPrint', 'dump', 'fatalError', 'getVaList', 'isKnownUniquelyReferenced', 'max', 'min', 'numericCast', 'pointwiseMax', 'pointwiseMin', 'precondition', 'preconditionFailure', 'print', 'readLine', 'repeatElement', 'sequence', 'stride', 'swap', 'swift_unboxFromSwiftValueWithType', 'transcode', 'type', 'unsafeBitCast', 'unsafeDowncast', 'withExtendedLifetime', 'withUnsafeMutablePointer', 'withUnsafePointer', 'withVaList', 'withoutActuallyEscaping', 'zip'];\n\n// Valid first characters for operators.\nconst operatorHead = either(/[/=\\-+!*%<>&|^~?]/, /[\\u00A1-\\u00A7]/, /[\\u00A9\\u00AB]/, /[\\u00AC\\u00AE]/, /[\\u00B0\\u00B1]/, /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/, /[\\u2016-\\u2017]/, /[\\u2020-\\u2027]/, /[\\u2030-\\u203E]/, /[\\u2041-\\u2053]/, /[\\u2055-\\u205E]/, /[\\u2190-\\u23FF]/, /[\\u2500-\\u2775]/, /[\\u2794-\\u2BFF]/, /[\\u2E00-\\u2E7F]/, /[\\u3001-\\u3003]/, /[\\u3008-\\u3020]/, /[\\u3030]/);\n\n// Valid characters for operators.\nconst operatorCharacter = either(operatorHead, /[\\u0300-\\u036F]/, /[\\u1DC0-\\u1DFF]/, /[\\u20D0-\\u20FF]/, /[\\uFE00-\\uFE0F]/, /[\\uFE20-\\uFE2F]/\n// TODO: The following characters are also allowed, but the regex isn't supported yet.\n// /[\\u{E0100}-\\u{E01EF}]/u\n);\n\n// Valid operator.\nconst operator = concat(operatorHead, operatorCharacter, '*');\n\n// Valid first characters for identifiers.\nconst identifierHead = either(/[a-zA-Z_]/, /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/, /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/, /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/, /[\\u1E00-\\u1FFF]/, /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/, /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/, /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/, /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/, /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/, /[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/ // Should be /[\\uFE47-\\uFFFD]/, but we have to exclude FEFF.\n// The following characters are also allowed, but the regexes aren't supported yet.\n// /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n// /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n// /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n// /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n);\n\n// Valid characters for identifiers.\nconst identifierCharacter = either(identifierHead, /\\d/, /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/);\n\n// Valid identifier.\nconst identifier = concat(identifierHead, identifierCharacter, '*');\n\n// Valid type identifier.\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\n\n// Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\n// https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes\nconst keywordAttributes = ['attached', 'autoclosure', concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/), 'discardableResult', 'dynamicCallable', 'dynamicMemberLookup', 'escaping', 'freestanding', 'frozen', 'GKInspectable', 'IBAction', 'IBDesignable', 'IBInspectable', 'IBOutlet', 'IBSegueAction', 'inlinable', 'main', 'nonobjc', 'NSApplicationMain', 'NSCopying', 'NSManaged', concat(/objc\\(/, identifier, /\\)/), 'objc', 'objcMembers', 'propertyWrapper', 'requires_stored_property_inits', 'resultBuilder', 'Sendable', 'testable', 'UIApplicationMain', 'unchecked', 'unknown', 'usableFromInline', 'warn_unqualified_access'];\n\n// Contextual keywords used in @available and #(un)available.\nconst availabilityKeywords = ['iOS', 'iOSApplicationExtension', 'macOS', 'macOSApplicationExtension', 'macCatalyst', 'macCatalystApplicationExtension', 'watchOS', 'watchOSApplicationExtension', 'tvOS', 'tvOSApplicationExtension', 'swift'];\n\n/*\nLanguage: Swift\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\nWebsite: https://swift.org\nCategory: common, system\n*/\n\n/** @type LanguageFn */\nfunction swift(hljs) {\n  const WHITESPACE = {\n    match: /\\s+/,\n    relevance: 0\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n  const BLOCK_COMMENT = hljs.COMMENT('/\\\\*', '\\\\*/', {\n    contains: ['self']\n  });\n  const COMMENTS = [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n  const DOT_KEYWORD = {\n    match: [/\\./, either(...dotKeywords, ...optionalDotKeywords)],\n    className: {\n      2: \"keyword\"\n    }\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    match: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords.filter(kw => typeof kw === 'string').concat([\"_|0\"]); // seems common, so 0 relevance\n  const REGEX_KEYWORDS = keywords.filter(kw => typeof kw !== 'string') // find regex\n  .concat(keywordTypes).map(keywordWrapper);\n  const KEYWORD = {\n    variants: [{\n      className: 'keyword',\n      match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n    }]\n  };\n  // find all the regular keywords\n  const KEYWORDS = {\n    $pattern: either(/\\b\\w+/,\n    // regular keywords\n    /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),\n    literal: literals\n  };\n  const KEYWORD_MODES = [DOT_KEYWORD, KEYWORD_GUARD, KEYWORD];\n\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    match: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    match: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [BUILT_IN_GUARD, BUILT_IN];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    match: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [{\n      match: operator\n    }, {\n      // dot-operator: only operators that start with a dot are allowed to use dots as\n      // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n      // characters that may also include dots.\n      match: \"\\\\.(\\\\.|\".concat(operatorCharacter, \")+\")\n    }]\n  };\n  const OPERATORS = [OPERATOR_GUARD, OPERATOR];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [\n    // decimal floating-point-literal (subsumes decimal-literal)\n    {\n      match: \"\\\\b(\".concat(decimalDigits, \")(\\\\.(\").concat(decimalDigits, \"))?\") + \"([eE][+-]?(\".concat(decimalDigits, \"))?\\\\b\")\n    },\n    // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n    {\n      match: \"\\\\b0x(\".concat(hexDigits, \")(\\\\.(\").concat(hexDigits, \"))?\") + \"([pP][+-]?(\".concat(decimalDigits, \"))?\\\\b\")\n    },\n    // octal-literal\n    {\n      match: /\\b0o([0-7]_*)+\\b/\n    },\n    // binary-literal\n    {\n      match: /\\b0b([01]_*)+\\b/\n    }]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n  const ESCAPED_CHARACTER = function () {\n    let rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return {\n      className: 'subst',\n      variants: [{\n        match: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\n      }, {\n        match: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\n      }]\n    };\n  };\n  const ESCAPED_NEWLINE = function () {\n    let rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return {\n      className: 'subst',\n      match: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n    };\n  };\n  const INTERPOLATION = function () {\n    let rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return {\n      className: 'subst',\n      label: \"interpol\",\n      begin: concat(/\\\\/, rawDelimiter, /\\(/),\n      end: /\\)/\n    };\n  };\n  const MULTILINE_STRING = function () {\n    let rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return {\n      begin: concat(rawDelimiter, /\"\"\"/),\n      end: concat(/\"\"\"/, rawDelimiter),\n      contains: [ESCAPED_CHARACTER(rawDelimiter), ESCAPED_NEWLINE(rawDelimiter), INTERPOLATION(rawDelimiter)]\n    };\n  };\n  const SINGLE_LINE_STRING = function () {\n    let rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return {\n      begin: concat(rawDelimiter, /\"/),\n      end: concat(/\"/, rawDelimiter),\n      contains: [ESCAPED_CHARACTER(rawDelimiter), INTERPOLATION(rawDelimiter)]\n    };\n  };\n  const STRING = {\n    className: 'string',\n    variants: [MULTILINE_STRING(), MULTILINE_STRING(\"#\"), MULTILINE_STRING(\"##\"), MULTILINE_STRING(\"###\"), SINGLE_LINE_STRING(), SINGLE_LINE_STRING(\"#\"), SINGLE_LINE_STRING(\"##\"), SINGLE_LINE_STRING(\"###\")]\n  };\n  const REGEXP_CONTENTS = [hljs.BACKSLASH_ESCAPE, {\n    begin: /\\[/,\n    end: /\\]/,\n    relevance: 0,\n    contains: [hljs.BACKSLASH_ESCAPE]\n  }];\n  const BARE_REGEXP_LITERAL = {\n    begin: /\\/[^\\s](?=[^/\\n]*\\/)/,\n    end: /\\//,\n    contains: REGEXP_CONTENTS\n  };\n  const EXTENDED_REGEXP_LITERAL = rawDelimiter => {\n    const begin = concat(rawDelimiter, /\\//);\n    const end = concat(/\\//, rawDelimiter);\n    return {\n      begin,\n      end,\n      contains: [...REGEXP_CONTENTS, {\n        scope: \"comment\",\n        begin: \"#(?!.*\".concat(end, \")\"),\n        end: /$/\n      }]\n    };\n  };\n\n  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/#Regular-Expression-Literals\n  const REGEXP = {\n    scope: \"regexp\",\n    variants: [EXTENDED_REGEXP_LITERAL('###'), EXTENDED_REGEXP_LITERAL('##'), EXTENDED_REGEXP_LITERAL('#'), BARE_REGEXP_LITERAL]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n  const QUOTED_IDENTIFIER = {\n    match: concat(/`/, identifier, /`/)\n  };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    match: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    match: \"\\\\$\".concat(identifierCharacter, \"+\")\n  };\n  const IDENTIFIERS = [QUOTED_IDENTIFIER, IMPLICIT_PARAMETER, PROPERTY_WRAPPER_PROJECTION];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n  const AVAILABLE_ATTRIBUTE = {\n    match: /(@|#(un)?)available/,\n    scope: 'keyword',\n    starts: {\n      contains: [{\n        begin: /\\(/,\n        end: /\\)/,\n        keywords: availabilityKeywords,\n        contains: [...OPERATORS, NUMBER, STRING]\n      }]\n    }\n  };\n  const KEYWORD_ATTRIBUTE = {\n    scope: 'keyword',\n    match: concat(/@/, either(...keywordAttributes), lookahead(either(/\\(/, /\\s+/)))\n  };\n  const USER_DEFINED_ATTRIBUTE = {\n    scope: 'meta',\n    match: concat(/@/, identifier)\n  };\n  const ATTRIBUTES = [AVAILABLE_ATTRIBUTE, KEYWORD_ATTRIBUTE, USER_DEFINED_ATTRIBUTE];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n  const TYPE = {\n    match: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [{\n      // Common Apple frameworks, for relevance boost\n      className: 'type',\n      match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n    }, {\n      // Type identifier\n      className: 'type',\n      match: typeIdentifier,\n      relevance: 0\n    }, {\n      // Optional type\n      match: /[?!]+/,\n      relevance: 0\n    }, {\n      // Variadic parameter\n      match: /\\.\\.\\./,\n      relevance: 0\n    }, {\n      // Protocol composition\n      match: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n      relevance: 0\n    }]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [...COMMENTS, ...KEYWORD_MODES, ...ATTRIBUTES, OPERATOR_GUARD, TYPE]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS);\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\n  // Prevents element names from being highlighted as keywords.\n  const TUPLE_ELEMENT_NAME = {\n    match: concat(identifier, /\\s*:/),\n    keywords: \"_|0\",\n    relevance: 0\n  };\n  // Matches tuples as well as the parameter list of a function type.\n  const TUPLE = {\n    begin: /\\(/,\n    end: /\\)/,\n    relevance: 0,\n    keywords: KEYWORDS,\n    contains: ['self', TUPLE_ELEMENT_NAME, ...COMMENTS, REGEXP, ...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS, ...ATTRIBUTES, TYPE]\n  };\n  const GENERIC_PARAMETERS = {\n    begin: /</,\n    end: />/,\n    keywords: 'repeat each',\n    contains: [...COMMENTS, TYPE]\n  };\n  const FUNCTION_PARAMETER_NAME = {\n    begin: either(lookahead(concat(identifier, /\\s*:/)), lookahead(concat(identifier, /\\s+/, identifier, /\\s*:/))),\n    end: /:/,\n    relevance: 0,\n    contains: [{\n      className: 'keyword',\n      match: /\\b_\\b/\n    }, {\n      className: 'params',\n      match: identifier\n    }]\n  };\n  const FUNCTION_PARAMETERS = {\n    begin: /\\(/,\n    end: /\\)/,\n    keywords: KEYWORDS,\n    contains: [FUNCTION_PARAMETER_NAME, ...COMMENTS, ...KEYWORD_MODES, ...OPERATORS, NUMBER, STRING, ...ATTRIBUTES, TYPE, TUPLE],\n    endsParent: true,\n    illegal: /[\"']/\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\n  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations/#Macro-Declaration\n  const FUNCTION_OR_MACRO = {\n    match: [/(func|macro)/, /\\s+/, either(QUOTED_IDENTIFIER.match, identifier, operator)],\n    className: {\n      1: \"keyword\",\n      3: \"title.function\"\n    },\n    contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE],\n    illegal: [/\\[/, /%/]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\n  const INIT_SUBSCRIPT = {\n    match: [/\\b(?:subscript|init[?!]?)/, /\\s*(?=[<(])/],\n    className: {\n      1: \"keyword\"\n    },\n    contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE],\n    illegal: /\\[|%/\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\n  const OPERATOR_DECLARATION = {\n    match: [/operator/, /\\s+/, operator],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    }\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\n  const PRECEDENCEGROUP = {\n    begin: [/precedencegroup/, /\\s+/, typeIdentifier],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    },\n    contains: [TYPE],\n    keywords: [...precedencegroupKeywords, ...literals],\n    end: /}/\n  };\n  const CLASS_FUNC_DECLARATION = {\n    match: [/class\\b/, /\\s+/, /func\\b/, /\\s+/, /\\b[A-Za-z_][A-Za-z0-9_]*\\b/],\n    scope: {\n      1: \"keyword\",\n      3: \"keyword\",\n      5: \"title.function\"\n    }\n  };\n  const CLASS_VAR_DECLARATION = {\n    match: [/class\\b/, /\\s+/, /var\\b/],\n    scope: {\n      1: \"keyword\",\n      3: \"keyword\"\n    }\n  };\n  const TYPE_DECLARATION = {\n    begin: [/(struct|protocol|class|extension|enum|actor)/, /\\s+/, identifier, /\\s*/],\n    beginScope: {\n      1: \"keyword\",\n      3: \"title.class\"\n    },\n    keywords: KEYWORDS,\n    contains: [GENERIC_PARAMETERS, ...KEYWORD_MODES, {\n      begin: /:/,\n      end: /\\{/,\n      keywords: KEYWORDS,\n      contains: [{\n        scope: \"title.class.inherited\",\n        match: typeIdentifier\n      }, ...KEYWORD_MODES],\n      relevance: 0\n    }]\n  };\n\n  // Add supported submodes to string interpolation.\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\n    interpolation.keywords = KEYWORDS;\n    const submodes = [...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS];\n    interpolation.contains = [...submodes, {\n      begin: /\\(/,\n      end: /\\)/,\n      contains: ['self', ...submodes]\n    }];\n  }\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [...COMMENTS, FUNCTION_OR_MACRO, INIT_SUBSCRIPT, CLASS_FUNC_DECLARATION, CLASS_VAR_DECLARATION, TYPE_DECLARATION, OPERATOR_DECLARATION, PRECEDENCEGROUP, {\n      beginKeywords: 'import',\n      end: /$/,\n      contains: [...COMMENTS],\n      relevance: 0\n    }, REGEXP, ...KEYWORD_MODES, ...BUILT_INS, ...OPERATORS, NUMBER, STRING, ...IDENTIFIERS, ...ATTRIBUTES, TYPE, TUPLE]\n  };\n}\nexport { swift as default };","map":{"version":3,"names":["source","re","lookahead","concat","_len","arguments","length","args","Array","_key","joined","map","x","join","stripOptionsFromArgs","opts","constructor","Object","splice","either","_len2","_key2","capture","keywordWrapper","keyword","test","dotKeywords","optionalDotKeywords","keywordTypes","keywords","literals","precedencegroupKeywords","numberSignKeywords","builtIns","operatorHead","operatorCharacter","operator","identifierHead","identifierCharacter","identifier","typeIdentifier","keywordAttributes","availabilityKeywords","swift","hljs","WHITESPACE","match","relevance","BLOCK_COMMENT","COMMENT","contains","COMMENTS","C_LINE_COMMENT_MODE","DOT_KEYWORD","className","KEYWORD_GUARD","PLAIN_KEYWORDS","filter","kw","REGEX_KEYWORDS","KEYWORD","variants","KEYWORDS","$pattern","literal","KEYWORD_MODES","BUILT_IN_GUARD","BUILT_IN","BUILT_INS","OPERATOR_GUARD","OPERATOR","OPERATORS","decimalDigits","hexDigits","NUMBER","ESCAPED_CHARACTER","rawDelimiter","undefined","ESCAPED_NEWLINE","INTERPOLATION","label","begin","end","MULTILINE_STRING","SINGLE_LINE_STRING","STRING","REGEXP_CONTENTS","BACKSLASH_ESCAPE","BARE_REGEXP_LITERAL","EXTENDED_REGEXP_LITERAL","scope","REGEXP","QUOTED_IDENTIFIER","IMPLICIT_PARAMETER","PROPERTY_WRAPPER_PROJECTION","IDENTIFIERS","AVAILABLE_ATTRIBUTE","starts","KEYWORD_ATTRIBUTE","USER_DEFINED_ATTRIBUTE","ATTRIBUTES","TYPE","GENERIC_ARGUMENTS","push","TUPLE_ELEMENT_NAME","TUPLE","GENERIC_PARAMETERS","FUNCTION_PARAMETER_NAME","FUNCTION_PARAMETERS","endsParent","illegal","FUNCTION_OR_MACRO","INIT_SUBSCRIPT","OPERATOR_DECLARATION","PRECEDENCEGROUP","CLASS_FUNC_DECLARATION","CLASS_VAR_DECLARATION","TYPE_DECLARATION","beginScope","variant","interpolation","find","mode","submodes","name","beginKeywords","default"],"sources":["/home/tonii/node_modules/highlight.js/es/languages/swift.js"],"sourcesContent":["/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/**\n * @param { Array<string | RegExp | Object> } args\n * @returns {object}\n */\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/** @typedef { {capture?: boolean} } RegexEitherOptions */\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args\n * @returns {string}\n */\nfunction either(...args) {\n  /** @type { object & {capture?: boolean} }  */\n  const opts = stripOptionsFromArgs(args);\n  const joined = '('\n    + (opts.capture ? \"\" : \"?:\")\n    + args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\nconst keywordWrapper = keyword => concat(\n  /\\b/,\n  keyword,\n  /\\w$/.test(keyword) ? /\\b/ : /\\B/\n);\n\n// Keywords that require a leading dot.\nconst dotKeywords = [\n  'Protocol', // contextual\n  'Type' // contextual\n].map(keywordWrapper);\n\n// Keywords that may have a leading dot.\nconst optionalDotKeywords = [\n  'init',\n  'self'\n].map(keywordWrapper);\n\n// should register as keyword, not type\nconst keywordTypes = [\n  'Any',\n  'Self'\n];\n\n// Regular keywords and literals.\nconst keywords = [\n  // strings below will be fed into the regular `keywords` engine while regex\n  // will result in additional modes being created to scan for those keywords to\n  // avoid conflicts with other rules\n  'actor',\n  'any', // contextual\n  'associatedtype',\n  'async',\n  'await',\n  /as\\?/, // operator\n  /as!/, // operator\n  'as', // operator\n  'borrowing', // contextual\n  'break',\n  'case',\n  'catch',\n  'class',\n  'consume', // contextual\n  'consuming', // contextual\n  'continue',\n  'convenience', // contextual\n  'copy', // contextual\n  'default',\n  'defer',\n  'deinit',\n  'didSet', // contextual\n  'distributed',\n  'do',\n  'dynamic', // contextual\n  'each',\n  'else',\n  'enum',\n  'extension',\n  'fallthrough',\n  /fileprivate\\(set\\)/,\n  'fileprivate',\n  'final', // contextual\n  'for',\n  'func',\n  'get', // contextual\n  'guard',\n  'if',\n  'import',\n  'indirect', // contextual\n  'infix', // contextual\n  /init\\?/,\n  /init!/,\n  'inout',\n  /internal\\(set\\)/,\n  'internal',\n  'in',\n  'is', // operator\n  'isolated', // contextual\n  'nonisolated', // contextual\n  'lazy', // contextual\n  'let',\n  'macro',\n  'mutating', // contextual\n  'nonmutating', // contextual\n  /open\\(set\\)/, // contextual\n  'open', // contextual\n  'operator',\n  'optional', // contextual\n  'override', // contextual\n  'package',\n  'postfix', // contextual\n  'precedencegroup',\n  'prefix', // contextual\n  /private\\(set\\)/,\n  'private',\n  'protocol',\n  /public\\(set\\)/,\n  'public',\n  'repeat',\n  'required', // contextual\n  'rethrows',\n  'return',\n  'set', // contextual\n  'some', // contextual\n  'static',\n  'struct',\n  'subscript',\n  'super',\n  'switch',\n  'throws',\n  'throw',\n  /try\\?/, // operator\n  /try!/, // operator\n  'try', // operator\n  'typealias',\n  /unowned\\(safe\\)/, // contextual\n  /unowned\\(unsafe\\)/, // contextual\n  'unowned', // contextual\n  'var',\n  'weak', // contextual\n  'where',\n  'while',\n  'willSet' // contextual\n];\n\n// NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n\n// Literals.\nconst literals = [\n  'false',\n  'nil',\n  'true'\n];\n\n// Keywords used in precedence groups.\nconst precedencegroupKeywords = [\n  'assignment',\n  'associativity',\n  'higherThan',\n  'left',\n  'lowerThan',\n  'none',\n  'right'\n];\n\n// Keywords that start with a number sign (#).\n// #(un)available is handled separately.\nconst numberSignKeywords = [\n  '#colorLiteral',\n  '#column',\n  '#dsohandle',\n  '#else',\n  '#elseif',\n  '#endif',\n  '#error',\n  '#file',\n  '#fileID',\n  '#fileLiteral',\n  '#filePath',\n  '#function',\n  '#if',\n  '#imageLiteral',\n  '#keyPath',\n  '#line',\n  '#selector',\n  '#sourceLocation',\n  '#warning'\n];\n\n// Global functions in the Standard Library.\nconst builtIns = [\n  'abs',\n  'all',\n  'any',\n  'assert',\n  'assertionFailure',\n  'debugPrint',\n  'dump',\n  'fatalError',\n  'getVaList',\n  'isKnownUniquelyReferenced',\n  'max',\n  'min',\n  'numericCast',\n  'pointwiseMax',\n  'pointwiseMin',\n  'precondition',\n  'preconditionFailure',\n  'print',\n  'readLine',\n  'repeatElement',\n  'sequence',\n  'stride',\n  'swap',\n  'swift_unboxFromSwiftValueWithType',\n  'transcode',\n  'type',\n  'unsafeBitCast',\n  'unsafeDowncast',\n  'withExtendedLifetime',\n  'withUnsafeMutablePointer',\n  'withUnsafePointer',\n  'withVaList',\n  'withoutActuallyEscaping',\n  'zip'\n];\n\n// Valid first characters for operators.\nconst operatorHead = either(\n  /[/=\\-+!*%<>&|^~?]/,\n  /[\\u00A1-\\u00A7]/,\n  /[\\u00A9\\u00AB]/,\n  /[\\u00AC\\u00AE]/,\n  /[\\u00B0\\u00B1]/,\n  /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,\n  /[\\u2016-\\u2017]/,\n  /[\\u2020-\\u2027]/,\n  /[\\u2030-\\u203E]/,\n  /[\\u2041-\\u2053]/,\n  /[\\u2055-\\u205E]/,\n  /[\\u2190-\\u23FF]/,\n  /[\\u2500-\\u2775]/,\n  /[\\u2794-\\u2BFF]/,\n  /[\\u2E00-\\u2E7F]/,\n  /[\\u3001-\\u3003]/,\n  /[\\u3008-\\u3020]/,\n  /[\\u3030]/\n);\n\n// Valid characters for operators.\nconst operatorCharacter = either(\n  operatorHead,\n  /[\\u0300-\\u036F]/,\n  /[\\u1DC0-\\u1DFF]/,\n  /[\\u20D0-\\u20FF]/,\n  /[\\uFE00-\\uFE0F]/,\n  /[\\uFE20-\\uFE2F]/\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\n  // /[\\u{E0100}-\\u{E01EF}]/u\n);\n\n// Valid operator.\nconst operator = concat(operatorHead, operatorCharacter, '*');\n\n// Valid first characters for identifiers.\nconst identifierHead = either(\n  /[a-zA-Z_]/,\n  /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,\n  /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,\n  /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,\n  /[\\u1E00-\\u1FFF]/,\n  /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,\n  /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,\n  /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,\n  /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,\n  /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,\n  /[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/ // Should be /[\\uFE47-\\uFFFD]/, but we have to exclude FEFF.\n  // The following characters are also allowed, but the regexes aren't supported yet.\n  // /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n  // /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n  // /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n  // /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n);\n\n// Valid characters for identifiers.\nconst identifierCharacter = either(\n  identifierHead,\n  /\\d/,\n  /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/\n);\n\n// Valid identifier.\nconst identifier = concat(identifierHead, identifierCharacter, '*');\n\n// Valid type identifier.\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\n\n// Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\n// https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes\nconst keywordAttributes = [\n  'attached',\n  'autoclosure',\n  concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/),\n  'discardableResult',\n  'dynamicCallable',\n  'dynamicMemberLookup',\n  'escaping',\n  'freestanding',\n  'frozen',\n  'GKInspectable',\n  'IBAction',\n  'IBDesignable',\n  'IBInspectable',\n  'IBOutlet',\n  'IBSegueAction',\n  'inlinable',\n  'main',\n  'nonobjc',\n  'NSApplicationMain',\n  'NSCopying',\n  'NSManaged',\n  concat(/objc\\(/, identifier, /\\)/),\n  'objc',\n  'objcMembers',\n  'propertyWrapper',\n  'requires_stored_property_inits',\n  'resultBuilder',\n  'Sendable',\n  'testable',\n  'UIApplicationMain',\n  'unchecked',\n  'unknown',\n  'usableFromInline',\n  'warn_unqualified_access'\n];\n\n// Contextual keywords used in @available and #(un)available.\nconst availabilityKeywords = [\n  'iOS',\n  'iOSApplicationExtension',\n  'macOS',\n  'macOSApplicationExtension',\n  'macCatalyst',\n  'macCatalystApplicationExtension',\n  'watchOS',\n  'watchOSApplicationExtension',\n  'tvOS',\n  'tvOSApplicationExtension',\n  'swift'\n];\n\n/*\nLanguage: Swift\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\nWebsite: https://swift.org\nCategory: common, system\n*/\n\n\n/** @type LanguageFn */\nfunction swift(hljs) {\n  const WHITESPACE = {\n    match: /\\s+/,\n    relevance: 0\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n  const BLOCK_COMMENT = hljs.COMMENT(\n    '/\\\\*',\n    '\\\\*/',\n    { contains: [ 'self' ] }\n  );\n  const COMMENTS = [\n    hljs.C_LINE_COMMENT_MODE,\n    BLOCK_COMMENT\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n  const DOT_KEYWORD = {\n    match: [\n      /\\./,\n      either(...dotKeywords, ...optionalDotKeywords)\n    ],\n    className: { 2: \"keyword\" }\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    match: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords\n    .filter(kw => typeof kw === 'string')\n    .concat([ \"_|0\" ]); // seems common, so 0 relevance\n  const REGEX_KEYWORDS = keywords\n    .filter(kw => typeof kw !== 'string') // find regex\n    .concat(keywordTypes)\n    .map(keywordWrapper);\n  const KEYWORD = { variants: [\n    {\n      className: 'keyword',\n      match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n    }\n  ] };\n  // find all the regular keywords\n  const KEYWORDS = {\n    $pattern: either(\n      /\\b\\w+/, // regular keywords\n      /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS\n      .concat(numberSignKeywords),\n    literal: literals\n  };\n  const KEYWORD_MODES = [\n    DOT_KEYWORD,\n    KEYWORD_GUARD,\n    KEYWORD\n  ];\n\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    match: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    match: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [\n    BUILT_IN_GUARD,\n    BUILT_IN\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    match: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [\n      { match: operator },\n      {\n        // dot-operator: only operators that start with a dot are allowed to use dots as\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n        // characters that may also include dots.\n        match: `\\\\.(\\\\.|${operatorCharacter})+` }\n    ]\n  };\n  const OPERATORS = [\n    OPERATOR_GUARD,\n    OPERATOR\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [\n      // decimal floating-point-literal (subsumes decimal-literal)\n      { match: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b` },\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n      { match: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b` },\n      // octal-literal\n      { match: /\\b0o([0-7]_*)+\\b/ },\n      // binary-literal\n      { match: /\\b0b([01]_*)+\\b/ }\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    variants: [\n      { match: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/) },\n      { match: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/) }\n    ]\n  });\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    match: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n  });\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    label: \"interpol\",\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\n    end: /\\)/\n  });\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"\"\"/),\n    end: concat(/\"\"\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      ESCAPED_NEWLINE(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"/),\n    end: concat(/\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const STRING = {\n    className: 'string',\n    variants: [\n      MULTILINE_STRING(),\n      MULTILINE_STRING(\"#\"),\n      MULTILINE_STRING(\"##\"),\n      MULTILINE_STRING(\"###\"),\n      SINGLE_LINE_STRING(),\n      SINGLE_LINE_STRING(\"#\"),\n      SINGLE_LINE_STRING(\"##\"),\n      SINGLE_LINE_STRING(\"###\")\n    ]\n  };\n\n  const REGEXP_CONTENTS = [\n    hljs.BACKSLASH_ESCAPE,\n    {\n      begin: /\\[/,\n      end: /\\]/,\n      relevance: 0,\n      contains: [ hljs.BACKSLASH_ESCAPE ]\n    }\n  ];\n\n  const BARE_REGEXP_LITERAL = {\n    begin: /\\/[^\\s](?=[^/\\n]*\\/)/,\n    end: /\\//,\n    contains: REGEXP_CONTENTS\n  };\n\n  const EXTENDED_REGEXP_LITERAL = (rawDelimiter) => {\n    const begin = concat(rawDelimiter, /\\//);\n    const end = concat(/\\//, rawDelimiter);\n    return {\n      begin,\n      end,\n      contains: [\n        ...REGEXP_CONTENTS,\n        {\n          scope: \"comment\",\n          begin: `#(?!.*${end})`,\n          end: /$/,\n        },\n      ],\n    };\n  };\n\n  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/lexicalstructure/#Regular-Expression-Literals\n  const REGEXP = {\n    scope: \"regexp\",\n    variants: [\n      EXTENDED_REGEXP_LITERAL('###'),\n      EXTENDED_REGEXP_LITERAL('##'),\n      EXTENDED_REGEXP_LITERAL('#'),\n      BARE_REGEXP_LITERAL\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n  const QUOTED_IDENTIFIER = { match: concat(/`/, identifier, /`/) };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    match: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    match: `\\\\$${identifierCharacter}+`\n  };\n  const IDENTIFIERS = [\n    QUOTED_IDENTIFIER,\n    IMPLICIT_PARAMETER,\n    PROPERTY_WRAPPER_PROJECTION\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n  const AVAILABLE_ATTRIBUTE = {\n    match: /(@|#(un)?)available/,\n    scope: 'keyword',\n    starts: { contains: [\n      {\n        begin: /\\(/,\n        end: /\\)/,\n        keywords: availabilityKeywords,\n        contains: [\n          ...OPERATORS,\n          NUMBER,\n          STRING\n        ]\n      }\n    ] }\n  };\n\n  const KEYWORD_ATTRIBUTE = {\n    scope: 'keyword',\n    match: concat(/@/, either(...keywordAttributes), lookahead(either(/\\(/, /\\s+/))),\n  };\n\n  const USER_DEFINED_ATTRIBUTE = {\n    scope: 'meta',\n    match: concat(/@/, identifier)\n  };\n\n  const ATTRIBUTES = [\n    AVAILABLE_ATTRIBUTE,\n    KEYWORD_ATTRIBUTE,\n    USER_DEFINED_ATTRIBUTE\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n  const TYPE = {\n    match: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [\n      { // Common Apple frameworks, for relevance boost\n        className: 'type',\n        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n      },\n      { // Type identifier\n        className: 'type',\n        match: typeIdentifier,\n        relevance: 0\n      },\n      { // Optional type\n        match: /[?!]+/,\n        relevance: 0\n      },\n      { // Variadic parameter\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      { // Protocol composition\n        match: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n        relevance: 0\n      }\n    ]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [\n      ...COMMENTS,\n      ...KEYWORD_MODES,\n      ...ATTRIBUTES,\n      OPERATOR_GUARD,\n      TYPE\n    ]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS);\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\n  // Prevents element names from being highlighted as keywords.\n  const TUPLE_ELEMENT_NAME = {\n    match: concat(identifier, /\\s*:/),\n    keywords: \"_|0\",\n    relevance: 0\n  };\n  // Matches tuples as well as the parameter list of a function type.\n  const TUPLE = {\n    begin: /\\(/,\n    end: /\\)/,\n    relevance: 0,\n    keywords: KEYWORDS,\n    contains: [\n      'self',\n      TUPLE_ELEMENT_NAME,\n      ...COMMENTS,\n      REGEXP,\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS,\n      ...ATTRIBUTES,\n      TYPE\n    ]\n  };\n\n  const GENERIC_PARAMETERS = {\n    begin: /</,\n    end: />/,\n    keywords: 'repeat each',\n    contains: [\n      ...COMMENTS,\n      TYPE\n    ]\n  };\n  const FUNCTION_PARAMETER_NAME = {\n    begin: either(\n      lookahead(concat(identifier, /\\s*:/)),\n      lookahead(concat(identifier, /\\s+/, identifier, /\\s*:/))\n    ),\n    end: /:/,\n    relevance: 0,\n    contains: [\n      {\n        className: 'keyword',\n        match: /\\b_\\b/\n      },\n      {\n        className: 'params',\n        match: identifier\n      }\n    ]\n  };\n  const FUNCTION_PARAMETERS = {\n    begin: /\\(/,\n    end: /\\)/,\n    keywords: KEYWORDS,\n    contains: [\n      FUNCTION_PARAMETER_NAME,\n      ...COMMENTS,\n      ...KEYWORD_MODES,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...ATTRIBUTES,\n      TYPE,\n      TUPLE\n    ],\n    endsParent: true,\n    illegal: /[\"']/\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\n  // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations/#Macro-Declaration\n  const FUNCTION_OR_MACRO = {\n    match: [\n      /(func|macro)/,\n      /\\s+/,\n      either(QUOTED_IDENTIFIER.match, identifier, operator)\n    ],\n    className: {\n      1: \"keyword\",\n      3: \"title.function\"\n    },\n    contains: [\n      GENERIC_PARAMETERS,\n      FUNCTION_PARAMETERS,\n      WHITESPACE\n    ],\n    illegal: [\n      /\\[/,\n      /%/\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\n  const INIT_SUBSCRIPT = {\n    match: [\n      /\\b(?:subscript|init[?!]?)/,\n      /\\s*(?=[<(])/,\n    ],\n    className: { 1: \"keyword\" },\n    contains: [\n      GENERIC_PARAMETERS,\n      FUNCTION_PARAMETERS,\n      WHITESPACE\n    ],\n    illegal: /\\[|%/\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\n  const OPERATOR_DECLARATION = {\n    match: [\n      /operator/,\n      /\\s+/,\n      operator\n    ],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    }\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\n  const PRECEDENCEGROUP = {\n    begin: [\n      /precedencegroup/,\n      /\\s+/,\n      typeIdentifier\n    ],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    },\n    contains: [ TYPE ],\n    keywords: [\n      ...precedencegroupKeywords,\n      ...literals\n    ],\n    end: /}/\n  };\n\n  const CLASS_FUNC_DECLARATION = {\n    match: [\n      /class\\b/,          \n      /\\s+/,\n      /func\\b/,\n      /\\s+/,\n      /\\b[A-Za-z_][A-Za-z0-9_]*\\b/ \n    ],\n    scope: {\n      1: \"keyword\",\n      3: \"keyword\",\n      5: \"title.function\"\n    }\n  };\n\n  const CLASS_VAR_DECLARATION = {\n    match: [\n      /class\\b/,\n      /\\s+/,          \n      /var\\b/, \n    ],\n    scope: {\n      1: \"keyword\",\n      3: \"keyword\"\n    }\n  };\n\n  const TYPE_DECLARATION = {\n    begin: [\n      /(struct|protocol|class|extension|enum|actor)/,\n      /\\s+/,\n      identifier,\n      /\\s*/,\n    ],\n    beginScope: {\n      1: \"keyword\",\n      3: \"title.class\"\n    },\n    keywords: KEYWORDS,\n    contains: [\n      GENERIC_PARAMETERS,\n      ...KEYWORD_MODES,\n      {\n        begin: /:/,\n        end: /\\{/,\n        keywords: KEYWORDS,\n        contains: [\n          {\n            scope: \"title.class.inherited\",\n            match: typeIdentifier,\n          },\n          ...KEYWORD_MODES,\n        ],\n        relevance: 0,\n      },\n    ]\n  };\n\n  // Add supported submodes to string interpolation.\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\n    interpolation.keywords = KEYWORDS;\n    const submodes = [\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS\n    ];\n    interpolation.contains = [\n      ...submodes,\n      {\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [\n          'self',\n          ...submodes\n        ]\n      }\n    ];\n  }\n\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [\n      ...COMMENTS,\n      FUNCTION_OR_MACRO,\n      INIT_SUBSCRIPT,\n      CLASS_FUNC_DECLARATION,\n      CLASS_VAR_DECLARATION,\n      TYPE_DECLARATION,\n      OPERATOR_DECLARATION,\n      PRECEDENCEGROUP,\n      {\n        beginKeywords: 'import',\n        end: /$/,\n        contains: [ ...COMMENTS ],\n        relevance: 0\n      },\n      REGEXP,\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS,\n      ...ATTRIBUTES,\n      TYPE,\n      TUPLE\n    ]\n  };\n}\n\nexport { swift as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}